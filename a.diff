diff --git a/framework/common/udmf_types_util.cpp b/framework/common/udmf_types_util.cpp
index 3268d7a..7777b02 100644
--- a/framework/common/udmf_types_util.cpp
+++ b/framework/common/udmf_types_util.cpp
@@ -22,6 +22,7 @@
 namespace OHOS {
 namespace ITypesUtil {
 using namespace UDMF;
+static constexpr int32_t NORMAL_MAX_PARCEL_SIZE = 128 * 1024 * 1024;
 template<>
 bool Marshalling(const UnifiedData &input, MessageParcel &parcel)
 {
@@ -42,9 +43,11 @@ bool Marshalling(const UnifiedData &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(UnifiedData &output, MessageParcel &parcel)
 {
+    auto dataSize = parcel.GetDataSize();
     auto size = parcel.ReadInt32();
-    if (size <= 0 || size > UnifiedData::MAX_DATA_SIZE) {
-        LOG_ERROR(UDMF_SERVICE, "UnifiedData is empty or too large!");
+    if (size <= 0 || size > UnifiedData::MAX_DATA_SIZE || dataSize > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_SERVICE,
+            "UnifiedData is empty or too large! dataSize is %{public}d, size is %{public}d", dataSize, size);
         return false;
     }
     auto rawData = parcel.ReadRawData(size);
@@ -82,8 +85,9 @@ bool Marshalling(const std::vector<UnifiedData> &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(std::vector<UnifiedData> &output, MessageParcel &parcel)
 {
+    auto dataSize = parcel.GetDataSize();
     auto size = parcel.ReadInt32();
-    if (size <= 0 || size > UnifiedData::MAX_DATA_SIZE) {
+    if (size <= 0 || size > UnifiedData::MAX_DATA_SIZE || dataSize > NORMAL_MAX_PARCEL_SIZE) {
         LOG_ERROR(UDMF_SERVICE, "UnifiedDataSet is empty or too large!");
         return false;
     }
@@ -111,6 +115,11 @@ bool Marshalling(const Summary &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(Summary &output, MessageParcel &parcel)
 {
+    auto dataSize = parcel.GetDataSize();
+    if (dataSize <= 0 || dataSize > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_SERVICE, "UnifiedData is empty or too large!");
+        return false;
+    }
     return ITypesUtil::Unmarshal(parcel, output.summary, output.totalSize, output.specificSummary,
         output.summaryFormat, output.version);
 }
@@ -124,6 +133,11 @@ bool Marshalling(const Privilege &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(Privilege &output, MessageParcel &parcel)
 {
+    auto size = parcel.GetDataSize();
+    if (size <= 0 || size > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_SERVICE, "Privilege is empty or too large!");
+        return false;
+    }
     return ITypesUtil::Unmarshal(parcel, output.tokenId, output.readPermission, output.writePermission);
 }
 
@@ -136,6 +150,11 @@ bool Marshalling(const CustomOption &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(CustomOption &output, MessageParcel &parcel)
 {
+    auto size = parcel.GetDataSize();
+    if (size <= 0 || size > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_SERVICE, "CustomOption is empty or too large!");
+        return false;
+    }
     return ITypesUtil::Unmarshal(parcel, output.intention, output.visibility);
 }
 
@@ -148,6 +167,11 @@ bool Marshalling(const QueryOption &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(QueryOption &output, MessageParcel &parcel)
 {
+    auto size = parcel.GetDataSize();
+    if (size <= 0 || size > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_SERVICE, "QueryOption is empty or too large!");
+        return false;
+    }
     return ITypesUtil::Unmarshal(parcel, output.key, output.intention);
 }
 
@@ -161,6 +185,11 @@ bool Marshalling(const UDType &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(UDType &output, MessageParcel &parcel)
 {
+    auto size = parcel.GetDataSize();
+    if (size <= 0 || size > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_FRAMEWORK, "UDType is empty or too large!");
+        return false;
+    }
     int32_t type;
     if (!ITypesUtil::Unmarshal(parcel, type)) {
         LOG_ERROR(UDMF_FRAMEWORK, "Unmarshal UDType failed!");
@@ -184,6 +213,11 @@ bool Marshalling(const Intention &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(Intention &output, MessageParcel &parcel)
 {
+    auto size = parcel.GetDataSize();
+    if (size <= 0 || size > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_FRAMEWORK, "Intention is empty or too large!");
+        return false;
+    }
     int32_t intention;
     if (!ITypesUtil::Unmarshal(parcel, intention)) {
         LOG_ERROR(UDMF_FRAMEWORK, "Unmarshal Intention failed!");
@@ -207,6 +241,11 @@ bool Marshalling(const Visibility &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(Visibility &output, MessageParcel &parcel)
 {
+    auto size = parcel.GetDataSize();
+    if (size <= 0 || size > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_FRAMEWORK, "Visibility is empty or too large!");
+        return false;
+    }
     int32_t visibility;
     if (!ITypesUtil::Unmarshal(parcel, visibility)) {
         LOG_ERROR(UDMF_FRAMEWORK, "Unmarshal Visibility failed!");
@@ -232,6 +271,11 @@ bool Marshalling(const AsyncProcessInfo &input, MessageParcel &parcel)
 template<>
 bool Unmarshalling(AsyncProcessInfo &output, MessageParcel &parcel)
 {
+    auto size = parcel.GetDataSize();
+    if (size <= 0 || size > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_FRAMEWORK, "AsyncProcessInfo is empty or too large!");
+        return false;
+    }
     uint32_t syncStatus;
     uint32_t permStatus;
     if (!ITypesUtil::Unmarshal(parcel, syncStatus, permStatus, output.srcDevName, output.syncFinished, output.syncTotal,
@@ -270,6 +314,11 @@ template<>
 bool Unmarshalling(DataLoadInfo &output, MessageParcel &parcel)
 {
     auto size = parcel.ReadInt32();
+    auto dataSize = parcel.GetDataSize();
+    if (size <= 0 || size > NORMAL_MAX_PARCEL_SIZE || dataSize > NORMAL_MAX_PARCEL_SIZE) {
+        LOG_ERROR(UDMF_SERVICE, "DataLoadInfo is empty or too large!");
+        return false;
+    }
     const uint8_t *rawData = reinterpret_cast<const uint8_t *>(parcel.ReadRawData(size));
     if (rawData == nullptr) {
         LOG_ERROR(UDMF_SERVICE, "RawData is null!");
diff --git a/framework/common/unittest/BUILD.gn b/framework/common/unittest/BUILD.gn
index b698ef3..9111a72 100644
--- a/framework/common/unittest/BUILD.gn
+++ b/framework/common/unittest/BUILD.gn
@@ -25,6 +25,7 @@ config("module_private_config") {
     "${udmf_interfaces_path}/innerkits/data",
     "${udmf_framework_path}/common/unittest/mock/include",
     "${udmf_framework_path}/innerkitsimpl/client/",
+    "mock/",
   ]
 }
 
@@ -90,6 +91,31 @@ ohos_unittest("UdmfTypesUtilTest") {
   ]
 }
 
+ohos_unittest("UdmfTypesUtilMockTest") {
+  module_out_path = module_output_path
+
+  sources = [
+    "mock/message_parcel_mock.cpp",
+    "udmf_types_util_mock_test.cpp",
+  ]
+
+  configs = [ ":module_private_config" ]
+
+  deps = common_deps
+
+  external_deps = common_external_deps
+
+  external_deps += [
+    "googletest:gmock_main",
+    "googletest:gtest_main",
+  ]
+
+  defines = [
+    "private=public",
+    "protected=public",
+  ]
+}
+
 ohos_unittest("UdmfTypesUtilAbnormalTest") {
   module_out_path = module_output_path
 
@@ -231,6 +257,7 @@ group("unittest") {
     ":EndianConverterTest",
     ":TlvUtilTest",
     ":UdmfTypesUtilAbnormalTest",
+    ":UdmfTypesUtilMockTest",
     ":UdmfTypesUtilTest",
     ":UtdCfgsCheckerTest",
   ]
diff --git a/framework/ndkimpl/data/udmf.cpp b/framework/ndkimpl/data/udmf.cpp
index f526070..aa5a7ca 100644
--- a/framework/ndkimpl/data/udmf.cpp
+++ b/framework/ndkimpl/data/udmf.cpp
@@ -43,6 +43,7 @@ using namespace OHOS::UDMF;
 
 static constexpr uint64_t MAX_RECORDS_COUNT = 4 * 1024 * 1024;
 static constexpr uint64_t MAX_KEY_STRING_LEN = 1 * 1024 * 1024;
+static constexpr uint64_t MAX_TYPES_COUNT = 1 * 1024 * 1024;
 static const std::map<std::string, UDType> FILE_TYPES = {
     { UDMF_META_GENERAL_FILE, UDType::FILE },
     { UDMF_META_AUDIO, UDType::AUDIO },
@@ -1134,7 +1135,8 @@ int OH_UdmfRecordProvider_SetData(OH_UdmfRecordProvider* provider, void* context
 int OH_UdmfRecord_SetProvider(OH_UdmfRecord* record, const char* const* types, unsigned int count,
     OH_UdmfRecordProvider* provider)
 {
-    if (!IsUnifiedRecordValid(record) || types == nullptr || count == 0 || provider == nullptr) {
+    if (!IsUnifiedRecordValid(record) || types == nullptr || count == 0
+        || count > MAX_TYPES_COUNT || provider == nullptr) {
         return UDMF_E_INVALID_PARAM;
     }
     std::shared_ptr<DataProviderImpl> providerBox = std::make_shared<DataProviderImpl>();
diff --git a/framework/ndkimpl/unittest/udmf_test.cpp b/framework/ndkimpl/unittest/udmf_test.cpp
index d7e4701..ef1c51b 100644
--- a/framework/ndkimpl/unittest/udmf_test.cpp
+++ b/framework/ndkimpl/unittest/udmf_test.cpp
@@ -43,6 +43,7 @@ using namespace OHOS::Security::AccessToken;
 using namespace OHOS::UDMF;
 
 namespace OHOS::Test {
+static constexpr uint64_t MAX_TYPES_COUNT = 1 * 1024 * 1024;
 class UDMFTest : public testing::Test {
 public:
     static void SetUpTestCase(void);
@@ -1421,6 +1422,39 @@ HWTEST_F(UDMFTest, OH_UdmfRecord_SetProvider002, TestSize.Level1)
     OH_UdmfRecordProvider_Destroy(provider);
 }
 
+/**
+ * @tc.name: OH_UdmfRecord_SetProvider003
+ * @tc.desc: valid parameters testcase of OH_UdmfRecord_SetProvider
+ * @tc.type: FUNC
+ */
+HWTEST_F(UDMFTest, OH_UdmfRecord_SetProvider003, TestSize.Level1)
+{
+    OH_UdmfRecord *record = OH_UdmfRecord_Create();
+    OH_UdsPlainText *plainText = OH_UdsPlainText_Create();
+    char content[] = "hello world";
+    OH_UdsPlainText_SetContent(plainText, content);
+    OH_UdmfRecord_AddPlainText(record, plainText);
+    OH_UdmfRecordProvider* provider = OH_UdmfRecordProvider_Create();
+    EXPECT_NE(provider, nullptr);
+    int num = 1;
+    void* context = &num;
+    OH_UdmfRecordProvider_SetData(provider, context, GetDataCallbackFunc, FinalizeFunc);
+    const char* types[3] = { "general.plain-text", "general.hyperlink", "general.html" };
+
+    int res = OH_UdmfRecord_SetProvider(record, types, MAX_TYPES_COUNT + 1, provider);
+    EXPECT_EQ(res, UDMF_E_INVALID_PARAM);
+
+    res = OH_UdmfRecord_SetProvider(record, types, 0, provider);
+    EXPECT_EQ(res, UDMF_E_INVALID_PARAM);
+
+    res = OH_UdmfRecord_SetProvider(record, nullptr, MAX_TYPES_COUNT + 1, provider);
+    EXPECT_EQ(res, UDMF_E_INVALID_PARAM);
+
+    res = OH_UdmfRecord_SetProvider(record, types, 3, nullptr);
+    EXPECT_EQ(res, UDMF_E_OK);
+    OH_UdmfRecordProvider_Destroy(provider);
+}
+
 /**
  * @tc.name: OH_Udmf_BuildRecordByOpenHarmonyArrayBuffer001
  * @tc.desc: test OH_UdmfRecord_AddArrayBuffer with invalid param
